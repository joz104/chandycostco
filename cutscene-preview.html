<!DOCTYPE html>
<html>
<head>
    <title>Cutscene Preview</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: Arial, sans-serif; }
        #controls {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 100;
            background: rgba(0,0,0,0.8);
            padding: 15px;
            border-radius: 8px;
            color: white;
        }
        button {
            margin: 5px;
            padding: 10px 20px;
            font-size: 14px;
            cursor: pointer;
            border: none;
            border-radius: 4px;
        }
        .cutscene-btn { background: #4CAF50; color: white; }
        .view-btn { background: #2196F3; color: white; }
        #info { margin-top: 10px; font-size: 12px; color: #aaa; }
    </style>
</head>
<body>
    <div id="controls">
        <div>
            <strong>Cutscene:</strong>
            <button class="cutscene-btn" onclick="loadCutscene(3)">3: Rio Grande</button>
            <button class="cutscene-btn" onclick="loadCutscene(5)">5: Suburbia</button>
        </div>
        <div style="margin-top: 10px;">
            <strong>Camera:</strong>
            <button class="view-btn" onclick="setView('front')">Front</button>
            <button class="view-btn" onclick="setView('elevated')">Elevated</button>
            <button class="view-btn" onclick="setView('left')">Left</button>
            <button class="view-btn" onclick="setView('right')">Right</button>
            <button class="view-btn" onclick="setView('top')">Top</button>
        </div>
        <div id="info">Click buttons to change view</div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        let scene, camera, renderer;
        let activeEnvironmentObjects = [];
        let animatedElements = [];
        window.sceneReady = false;

        function init() {
            console.log('Initializing scene...');

            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a2a3a);

            // Camera
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 5, 15);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.body.appendChild(renderer.domElement);

            // Lighting
            const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.8);
            scene.add(hemiLight);

            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight.position.set(10, 20, 10);
            dirLight.castShadow = true;
            scene.add(dirLight);

            // Resize handler
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });

            // Start with cutscene 3
            loadCutscene(3);
            animate();

            window.sceneReady = true;
            console.log('Scene ready!');
        }

        function animate() {
            requestAnimationFrame(animate);
            updateAnimations();
            renderer.render(scene, camera);
        }

        function updateAnimations() {
            const time = Date.now() * 0.001;
            animatedElements.forEach(element => {
                if (element.type === 'water') {
                    updateWaterRipples(element.mesh, time);
                } else if (element.type === 'reed') {
                    element.mesh.rotation.z = Math.sin(time * 1.5 + element.offset) * 0.15;
                }
            });
        }

        function updateWaterRipples(waterMesh, time) {
            const geometry = waterMesh.geometry;
            const positions = geometry.attributes.position;
            const originalPositions = waterMesh.userData.originalPositions;
            if (!originalPositions) return;

            for (let i = 0; i < positions.count; i++) {
                const x = originalPositions[i * 3];
                const y = originalPositions[i * 3 + 1];
                const wave1 = Math.sin(x * 0.5 + time * 1.5) * 0.25;
                const wave2 = Math.sin(y * 0.6 + time * 1.8) * 0.18;
                const wave3 = Math.sin((x + y) * 0.4 + time * 1.2) * 0.2;
                positions.setZ(i, wave1 + wave2 + wave3);
            }
            positions.needsUpdate = true;
            geometry.computeVertexNormals();
        }

        function removeCutsceneEnvironment() {
            activeEnvironmentObjects.forEach(obj => {
                scene.remove(obj);
                obj.traverse(child => {
                    if (child.geometry) child.geometry.dispose();
                    if (child.material) {
                        if (Array.isArray(child.material)) {
                            child.material.forEach(mat => mat.dispose());
                        } else {
                            child.material.dispose();
                        }
                    }
                });
            });
            activeEnvironmentObjects = [];
            animatedElements = [];
        }

        window.loadCutscene = function(id) {
            if (!scene) return;
            removeCutsceneEnvironment();

            if (id === 3) {
                createRioGrandeEnvironment();
                scene.background = new THREE.Color(0x1a2a3a);
            } else if (id === 5) {
                createSuburbiaEnvironment();
                scene.background = new THREE.Color(0x87CEEB);
            }
            document.getElementById('info').textContent = `Viewing Cutscene ${id}`;
        };

        window.setView = function(view) {
            if (!camera || !renderer) return;
            const target = new THREE.Vector3(0, 1, -5);
            switch(view) {
                case 'front':
                    camera.position.set(0, 4, 15);
                    target.set(0, 1, -5);
                    break;
                case 'elevated':
                    camera.position.set(0, 12, 18);
                    target.set(0, 0, -5);
                    break;
                case 'left':
                    camera.position.set(-18, 5, 5);
                    target.set(0, 1, -5);
                    break;
                case 'right':
                    camera.position.set(18, 5, 5);
                    target.set(0, 1, -5);
                    break;
                case 'top':
                    camera.position.set(0, 25, 0);
                    target.set(0, 0, -5);
                    break;
            }
            camera.lookAt(target);
        };

        // ================= RIO GRANDE =================
        function createRioGrandeEnvironment() {
            const group = new THREE.Group();

            // Sky
            const bgGeo = new THREE.PlaneGeometry(60, 30);
            const bgMat = new THREE.MeshBasicMaterial({ color: 0x2a3a4a, side: THREE.DoubleSide });
            const background = new THREE.Mesh(bgGeo, bgMat);
            background.position.set(0, 8, -20);
            group.add(background);

            // Water
            const waterGeo = new THREE.PlaneGeometry(40, 30, 40, 30);
            const waterMat = new THREE.MeshStandardMaterial({
                color: 0x1C3030,
                roughness: 0.5,
                metalness: 0.2,
                transparent: true,
                opacity: 0.92
            });
            const water = new THREE.Mesh(waterGeo, waterMat);
            water.rotation.x = -Math.PI / 2;
            water.position.set(0, -0.5, 0);
            water.userData.originalPositions = new Float32Array(waterGeo.attributes.position.array);
            group.add(water);
            animatedElements.push({ type: 'water', mesh: water });

            // Reeds
            const reedMat = new THREE.MeshStandardMaterial({ color: 0x3a4a2a });
            const reedTopMat = new THREE.MeshStandardMaterial({ color: 0x4a3020 });

            for (let i = 0; i < 12; i++) {
                const reed = new THREE.Group();
                const stem = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.08, 2.5, 6), reedMat);
                stem.position.y = 1.25;
                reed.add(stem);
                const top = new THREE.Mesh(new THREE.CylinderGeometry(0.12, 0.1, 0.5, 8), reedTopMat);
                top.position.y = 2.75;
                reed.add(top);
                reed.position.set(-8 + Math.random() * 2, 0, -5 + i * 1.5);
                group.add(reed);
                animatedElements.push({ type: 'reed', mesh: reed, offset: i * 0.5 });
            }

            for (let i = 0; i < 12; i++) {
                const reed = new THREE.Group();
                const stem = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.08, 2.5, 6), reedMat);
                stem.position.y = 1.25;
                reed.add(stem);
                const top = new THREE.Mesh(new THREE.CylinderGeometry(0.12, 0.1, 0.5, 8), reedTopMat);
                top.position.y = 2.75;
                reed.add(top);
                reed.position.set(8 - Math.random() * 2, 0, -5 + i * 1.5);
                group.add(reed);
                animatedElements.push({ type: 'reed', mesh: reed, offset: i * 0.5 + Math.PI });
            }

            // Log
            const logMat = new THREE.MeshStandardMaterial({ color: 0x3a2a1a });
            const log = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.3, 3, 8), logMat);
            log.rotation.z = Math.PI / 2;
            log.position.set(-2, 0, -8);
            group.add(log);

            // Warning sign
            const signGroup = new THREE.Group();
            const postMat = new THREE.MeshStandardMaterial({ color: 0x4a3020 });
            const signPost = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.12, 3, 6), postMat);
            signPost.position.y = 1.5;
            signGroup.add(signPost);
            const signBoardMat = new THREE.MeshStandardMaterial({ color: 0x8B2500 });
            const signBoard = new THREE.Mesh(new THREE.BoxGeometry(1.2, 0.8, 0.1), signBoardMat);
            signBoard.position.set(0, 2.8, 0);
            signGroup.add(signBoard);
            const skullMat = new THREE.MeshStandardMaterial({ color: 0xE0D8C0 });
            const skull = new THREE.Mesh(new THREE.SphereGeometry(0.15, 8, 6), skullMat);
            skull.position.set(0, 2.85, 0.08);
            signGroup.add(skull);
            signGroup.position.set(-6, 0, -2);
            group.add(signGroup);

            // Debris
            const debrisMat = new THREE.MeshStandardMaterial({ color: 0x2a2015 });
            const branch1 = new THREE.Mesh(new THREE.CylinderGeometry(0.08, 0.05, 1.5, 5), debrisMat);
            branch1.rotation.set(0.2, 0.5, Math.PI / 2);
            branch1.position.set(3, 0.1, -5);
            group.add(branch1);

            const tireMat = new THREE.MeshStandardMaterial({ color: 0x1a1a1a });
            const tire = new THREE.Mesh(new THREE.TorusGeometry(0.4, 0.15, 8, 12), tireMat);
            tire.rotation.x = Math.PI / 2 + 0.3;
            tire.position.set(4, 0.1, -7);
            group.add(tire);

            // Dead trees
            const deadTreeMat = new THREE.MeshStandardMaterial({ color: 0x2a2520 });
            const deadTree1 = new THREE.Group();
            const trunk1 = new THREE.Mesh(new THREE.CylinderGeometry(0.15, 0.25, 4, 6), deadTreeMat);
            trunk1.position.y = 2;
            deadTree1.add(trunk1);
            const branch1a = new THREE.Mesh(new THREE.CylinderGeometry(0.03, 0.08, 1.5, 5), deadTreeMat);
            branch1a.position.set(-0.5, 3.2, 0);
            branch1a.rotation.z = Math.PI / 4;
            deadTree1.add(branch1a);
            deadTree1.position.set(-10, 0, -4);
            group.add(deadTree1);

            const deadTree2 = new THREE.Group();
            const trunk2 = new THREE.Mesh(new THREE.CylinderGeometry(0.12, 0.2, 2.5, 6), deadTreeMat);
            trunk2.position.y = 1.25;
            deadTree2.add(trunk2);
            deadTree2.position.set(10, 0, -6);
            group.add(deadTree2);

            scene.add(group);
            activeEnvironmentObjects.push(group);
        }

        // ================= SUBURBIA =================
        function createSuburbiaEnvironment() {
            const group = new THREE.Group();

            // Sky
            const bgGeo = new THREE.PlaneGeometry(60, 30);
            const bgMat = new THREE.MeshBasicMaterial({ color: 0x87CEEB, side: THREE.DoubleSide });
            const background = new THREE.Mesh(bgGeo, bgMat);
            background.position.set(0, 8, -20);
            group.add(background);

            // Clouds
            const cloudMat = new THREE.MeshBasicMaterial({ color: 0xFFFFFF });
            for (let i = 0; i < 3; i++) {
                const cloud = new THREE.Mesh(new THREE.SphereGeometry(1.5, 8, 6), cloudMat);
                cloud.position.set(-10 + i * 10, 10 + Math.random() * 3, -18);
                cloud.scale.set(1 + Math.random(), 0.6, 1);
                group.add(cloud);
            }

            // Street
            const streetMat = new THREE.MeshStandardMaterial({ color: 0x404040 });
            const street = new THREE.Mesh(new THREE.PlaneGeometry(40, 20), streetMat);
            street.rotation.x = -Math.PI / 2;
            street.position.set(0, 0, -5);
            group.add(street);

            // Yellow lines
            const lineMat = new THREE.MeshBasicMaterial({ color: 0xFFD700 });
            for (let i = 0; i < 6; i++) {
                const line = new THREE.Mesh(new THREE.BoxGeometry(2, 0.02, 0.15), lineMat);
                line.position.set(-10 + i * 4, 0.01, -5);
                group.add(line);
            }

            // Sidewalk
            const sidewalkMat = new THREE.MeshStandardMaterial({ color: 0xC0C0C0 });
            const sidewalk = new THREE.Mesh(new THREE.BoxGeometry(40, 0.1, 2), sidewalkMat);
            sidewalk.position.set(0, 0.05, -12);
            group.add(sidewalk);

            // Houses
            const houseColors = [0xFFE4B5, 0xB8D4E8, 0xF5DEB3, 0xE8D8C8];
            const roofColors = [0x8B4513, 0x696969, 0x8B0000, 0x4a4a4a];

            for (let i = 0; i < 4; i++) {
                const houseGroup = new THREE.Group();
                const houseMat = new THREE.MeshStandardMaterial({ color: houseColors[i] });
                const houseBody = new THREE.Mesh(new THREE.BoxGeometry(3.5, 2.8, 3), houseMat);
                houseBody.position.y = 1.4;
                houseGroup.add(houseBody);

                const roofMat = new THREE.MeshStandardMaterial({ color: roofColors[i] });
                const roof = new THREE.Mesh(new THREE.ConeGeometry(2.8, 1.8, 4), roofMat);
                roof.rotation.y = Math.PI / 4;
                roof.position.y = 3.7;
                houseGroup.add(roof);

                const doorMat = new THREE.MeshStandardMaterial({ color: 0x4a3020 });
                const door = new THREE.Mesh(new THREE.BoxGeometry(0.6, 1.4, 0.1), doorMat);
                door.position.set(0, 0.7, 1.55);
                houseGroup.add(door);

                const windowMat = new THREE.MeshStandardMaterial({ color: 0x87CEEB });
                const win1 = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.6, 0.1), windowMat);
                win1.position.set(-0.9, 1.8, 1.55);
                houseGroup.add(win1);
                const win2 = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.6, 0.1), windowMat);
                win2.position.set(0.9, 1.8, 1.55);
                houseGroup.add(win2);

                houseGroup.position.set(-12 + i * 7, 0, -14);
                group.add(houseGroup);
            }

            // Street lights
            const poleMat = new THREE.MeshStandardMaterial({ color: 0x2a2a2a });
            const lampMat = new THREE.MeshBasicMaterial({ color: 0xFFFACD });
            for (let i = 0; i < 3; i++) {
                const lampGroup = new THREE.Group();
                const pole = new THREE.Mesh(new THREE.CylinderGeometry(0.08, 0.1, 4, 8), poleMat);
                pole.position.y = 2;
                lampGroup.add(pole);
                const arm = new THREE.Mesh(new THREE.BoxGeometry(1, 0.08, 0.08), poleMat);
                arm.position.set(0.5, 3.9, 0);
                lampGroup.add(arm);
                const lampHead = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.25, 0.3), lampMat);
                lampHead.position.set(1, 3.75, 0);
                lampGroup.add(lampHead);
                lampGroup.position.set(-10 + i * 10, 0, -1);
                group.add(lampGroup);
            }

            // Cars
            const carColors = [0x1E90FF, 0xDC143C];
            for (let c = 0; c < 2; c++) {
                const carGroup = new THREE.Group();
                const carMat = new THREE.MeshStandardMaterial({ color: carColors[c], metalness: 0.4 });
                const body = new THREE.Mesh(new THREE.BoxGeometry(2.5, 0.8, 1.2), carMat);
                body.position.y = 0.5;
                carGroup.add(body);
                const cabin = new THREE.Mesh(new THREE.BoxGeometry(1.4, 0.6, 1.1), carMat);
                cabin.position.set(0.2, 1.0, 0);
                carGroup.add(cabin);
                const wheelMat = new THREE.MeshStandardMaterial({ color: 0x1a1a1a });
                [[-0.7, 0.25, 0.6], [-0.7, 0.25, -0.6], [0.7, 0.25, 0.6], [0.7, 0.25, -0.6]].forEach(pos => {
                    const wheel = new THREE.Mesh(new THREE.CylinderGeometry(0.25, 0.25, 0.2, 12), wheelMat);
                    wheel.rotation.x = Math.PI / 2;
                    wheel.position.set(pos[0], pos[1], pos[2]);
                    carGroup.add(wheel);
                });
                carGroup.position.set(-6 + c * 12, 0, -3);
                group.add(carGroup);
            }

            // Mailboxes
            const mailboxMat = new THREE.MeshStandardMaterial({ color: 0x2a2a2a });
            const mailboxFlagMat = new THREE.MeshStandardMaterial({ color: 0xFF0000 });
            for (let m = 0; m < 3; m++) {
                const mbGroup = new THREE.Group();
                const post = new THREE.Mesh(new THREE.BoxGeometry(0.1, 1.2, 0.1), mailboxMat);
                post.position.y = 0.6;
                mbGroup.add(post);
                const box = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.3, 0.25), mailboxMat);
                box.position.set(0, 1.25, 0);
                mbGroup.add(box);
                const flag = new THREE.Mesh(new THREE.BoxGeometry(0.02, 0.15, 0.1), mailboxFlagMat);
                flag.position.set(0.27, 1.35, 0);
                mbGroup.add(flag);
                mbGroup.position.set(-9 + m * 7, 0, -10);
                group.add(mbGroup);
            }

            // Trees
            const trunkMat = new THREE.MeshStandardMaterial({ color: 0x5D4037 });
            const leavesMat = new THREE.MeshStandardMaterial({ color: 0x228B22 });
            for (let t = 0; t < 4; t++) {
                const treeGroup = new THREE.Group();
                const trunk = new THREE.Mesh(new THREE.CylinderGeometry(0.15, 0.2, 1.5, 8), trunkMat);
                trunk.position.y = 0.75;
                treeGroup.add(trunk);
                const leaves = new THREE.Mesh(new THREE.ConeGeometry(1, 2, 8), leavesMat);
                leaves.position.y = 2.2;
                treeGroup.add(leaves);
                treeGroup.position.set(-11 + t * 7 + 2, 0, -11);
                group.add(treeGroup);
            }

            // Fire hydrant
            const hydrantMat = new THREE.MeshStandardMaterial({ color: 0xFF4500 });
            const hydrant = new THREE.Group();
            const hydrantBody = new THREE.Mesh(new THREE.CylinderGeometry(0.15, 0.18, 0.6, 8), hydrantMat);
            hydrantBody.position.y = 0.3;
            hydrant.add(hydrantBody);
            hydrant.position.set(5, 0, -1);
            group.add(hydrant);

            // Picket fence
            const fenceMat = new THREE.MeshStandardMaterial({ color: 0xFFFFFF });
            for (let i = 0; i < 12; i++) {
                const picket = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.9, 0.08), fenceMat);
                picket.position.set(-8 + i * 1.2, 0.45, -9);
                group.add(picket);
            }
            const rail = new THREE.Mesh(new THREE.BoxGeometry(14, 0.06, 0.06), fenceMat);
            rail.position.set(-1.4, 0.75, -9);
            group.add(rail);
            const rail2 = new THREE.Mesh(new THREE.BoxGeometry(14, 0.06, 0.06), fenceMat);
            rail2.position.set(-1.4, 0.25, -9);
            group.add(rail2);

            scene.add(group);
            activeEnvironmentObjects.push(group);
        }

        // Initialize when DOM is ready
        init();
    </script>
</body>
</html>
